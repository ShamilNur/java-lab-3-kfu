package ru.kpfu.itis.group903.nurkaev.repositories;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Repository;
import ru.kpfu.itis.group903.nurkaev.exceptions.DuplicateEntryException;
import ru.kpfu.itis.group903.nurkaev.exceptions.WrongEmailOrPasswordException;
import ru.kpfu.itis.group903.nurkaev.dto.LoginDto;
import ru.kpfu.itis.group903.nurkaev.dto.UserDto;
import ru.kpfu.itis.group903.nurkaev.models.User;

import javax.sql.DataSource;
import java.util.*;

import static ru.kpfu.itis.group903.nurkaev.queries.UserQueries.*;

/**
 * @author Shamil Nurkaev @nshamil
 * 11-903
 * Sem 1
 */

@Repository(value = "usersRepository")
public class UsersRepositoryJdbcImpl implements UsersRepository {
    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    private final PasswordEncoder encoder;

    private final RowMapper<User> userRowMapper = (row, rowNumber) -> User.builder()
            .id(row.getLong("id"))
            .firstName(row.getString("first_name"))
            .lastName(row.getString("last_name"))
            .email(row.getString("email"))
            .hashPassword(row.getString("hash_password"))
            .roomsId(row.getString("rooms_id"))
            .build();

    @Autowired
    public UsersRepositoryJdbcImpl(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        this.encoder = new BCryptPasswordEncoder();
    }

    @Override
    public void signUp(UserDto userDto) throws DuplicateEntryException {
        Optional<User> userOptional = findOneByEmail(userDto.getEmail());
        // разрешаем регистрацию, если данные пользователя ранее не были добавлены в БД
        if (!userOptional.isPresent()) {
            User user = User.builder()
                    .firstName(userDto.getFirstName())
                    .lastName(userDto.getLastName())
                    .email(userDto.getEmail())
                    .hashPassword(encoder.encode(userDto.getPassword()))
                    .build();
            save(user);
        } else throw new DuplicateEntryException();
    }

    @Override
    public void signIn(LoginDto loginDto) throws WrongEmailOrPasswordException {
        Optional<User> userOptional = findOneByEmail(loginDto.getEmail());
        if (userOptional.isPresent()) {
            User user = userOptional.get();
            if (!encoder.matches(loginDto.getPassword(), user.getHashPassword())) {
                throw new WrongEmailOrPasswordException();
            }
        } else throw new WrongEmailOrPasswordException();
    }

    @Override
    public void save(User entity) {
        Map<String, Object> params = new HashMap<>();
        params.put("first_name", entity.getFirstName());
        params.put("last_name", entity.getLastName());
        params.put("email", entity.getEmail());
        params.put("hash_password", entity.getHashPassword());
        params.put("rooms_id", entity.getRoomsId());
        // Saving the entity and setting the id value generated by the database
        SqlParameterSource sqlParameterSource = new MapSqlParameterSource(params);
        KeyHolder keyHolder = new GeneratedKeyHolder();
        namedParameterJdbcTemplate.update(SQL_INSERT, sqlParameterSource, keyHolder);
        Long id = Long.parseLong(Objects.requireNonNull(keyHolder.getKeys(),
                "The key was not generated, error with the database has occurred.")
                .get("id").toString());
        entity.setId(id);
    }

    @Override
    public void update(User entity) {
        Map<String, Object> params = new HashMap<>();
        params.put("id", entity.getId());
        params.put("first_name", entity.getFirstName());
        params.put("last_name", entity.getLastName());
        params.put("email", entity.getEmail());
        params.put("rooms_id", entity.getRoomsId());
        namedParameterJdbcTemplate.update(SQL_UPDATE_BY_ID, params);
    }

    @Override
    public void delete(User entity) {
        namedParameterJdbcTemplate.update(SQL_DELETE_BY_ID, Collections.singletonMap("id", entity.getId()));
    }

    @Override
    public void deleteByEmail(String email) {
        namedParameterJdbcTemplate.update(SQL_DELETE_BY_EMAIL, Collections.singletonMap("id", email));
    }

    @Override
    public void updateByEmail(String firstName, String lastName, String email) {
        Map<String, Object> params = new HashMap<>();
        params.put("first_name", firstName);
        params.put("last_name", lastName);
        params.put("email", email);
        namedParameterJdbcTemplate.update(SQL_UPDATE_BY_EMAIL, params);
    }

    @Override
    public Optional<User> findById(Long id) {
        User user;
        try {
            user = namedParameterJdbcTemplate.queryForObject(SQL_SELECT_BY_ID,
                    Collections.singletonMap("id", id), userRowMapper);
        } catch (EmptyResultDataAccessException e) {
            user = null;
        }

        return Optional.ofNullable(user);
    }

    @Override
    public Optional<User> findOneByEmail(String email) {
        User user;
        try {
            user = namedParameterJdbcTemplate.queryForObject(SQL_SELECT_BY_EMAIL,
                    Collections.singletonMap("email", email), userRowMapper);
        } catch (EmptyResultDataAccessException e) {
            user = null;
        }

        return Optional.ofNullable(user);
    }

    @Override
    public List<User> findAll() {
        return namedParameterJdbcTemplate.query(SQL_SELECT, userRowMapper);
    }
}
